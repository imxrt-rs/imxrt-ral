searchState.loadedDescShard("imxrt_ral", 5, "Pull/Keeper Enabled\nKeeper\nPull\n100K Ohm Pull Down\n47K Ohm Pull Up\n100K Ohm Pull Up\n22K Ohm Pull Up\nmedium(100MHz)\nSlow Slew Rate\nFast Slew Rate\nGPR0 General Purpose Register\nGPR1 General Purpose Register\nGPR2 General Purpose Register\nGPR3 General Purpose Register\nGPR3 General Purpose Register\nIOMUXC\nIOMUXC\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nDCDC_IN low voltage detect.\nDCDC output over current alert\nDCDC output over voltage alert\nDCDC captured status clear\nDCDC status OK\nSet to enable LPSR mode.\nPOR_B pad control\nKeypad Data Direction Register\nKeypad Data Direction Register\nKeypad Control Register\nKeypad Control Register\nKeypad Data Register\nKeypad Data Register\nKPP Registers\nKeypad Status Register\nKeypad Status Register\nKPP Registers\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nKeypad Column Data Direction Register\nKeypad Row Data Direction\nCOLn pin is configured as an input.\nCOLn pin is configured as an output.\nROWn pin configured as an input.\nROWn pin configured as an output.\nKeypad Column Strobe Open-Drain Enable\nKeypad Row Enable\nColumn strobe output is open drain.\nColumn strobe output is totem pole drive.\nRow is not included in the keypad key press detect.\nRow is included in the keypad key press detect.\nKeypad Column Data\nKeypad Row Data\nKeypad Key Depress Interrupt Enable\nKey Depress Synchronizer Clear\nKeypad Key Depress\nKeypad Key Release\nKeypad Release Interrupt Enable\nKey Release Synchronizer Set\nNo interrupt request is generated when KPKD is set.\nAn interrupt request is generated when KPKD is set.\nNo effect\nSet bits that clear the keypad depress synchronizer chain\nNo key presses detected\nA key has been depressed\nNo key release detected\nAll keys have been released\nNo interrupt request is generated when KPKR is set.\nAn interrupt request is generated when KPKR is set.\nNo effect\nSet bits which sets keypad release synchronizer chain\nBus Master Error Status Register\nBus Master Error Status Register\nCRC Status Register\nCRC Status Register\nLCDIF General Control Register\nLCDIF General Control Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control1 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control2 Register\nLCDIF General Control Register\nLCDIF General Control Register\nLCDIF General Control Register\nLCDIF General Control Register\nLCDIF General Control Register\nLCDIF General Control Register\nLCD Interface Current Buffer Address Register\nLCD Interface Current Buffer Address Register\nLCDIF Register Reference Index\nLookup Table Control Register.\nLookup Table Control Register.\nLookup Table Data Register.\nLookup Table Data Register.\nLookup Table Control Register.\nLookup Table Control Register.\nLookup Table Data Register.\nLookup Table Data Register.\nLookup Table Data Register.\nLookup Table Data Register.\nLCD Interface Next Buffer Address Register\nLCD Interface Next Buffer Address Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control0 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control1 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nLCDIF Pigeon Mode Control2 Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nPanel Interface Signal Generator Register\nLCDIF Register Reference Index\nLCD Interface Status Register\nLCD Interface Status Register\nLCDIF Horizontal and Vertical Valid Data Count Register\nLCDIF Horizontal and Vertical Valid Data Count Register\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register0\nLCDIF VSYNC Mode and Dotclk Mode Control Register1\nLCDIF VSYNC Mode and Dotclk Mode Control Register1\nLCDIF VSYNC Mode and Dotclk Mode Control Register2\nLCDIF VSYNC Mode and Dotclk Mode Control Register2\nLCDIF VSYNC Mode and Dotclk Mode Control Register3\nLCDIF VSYNC Mode and Dotclk Mode Control Register3\nLCDIF VSYNC Mode and Dotclk Mode Control Register4\nLCDIF VSYNC Mode and Dotclk Mode Control Register4\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nVirtual address at which bus master error occurred.\nCalculated CRC value.\nWhen this bit is 0, it means that LCDIF will stop the …\nThis bit must be set to zero for normal operation\nThis field specifies how to swap the bytes after the data …\nWhen this bit is 1 and WORD_LENGTH = 0, it implies that …\nUsed only when WORD_LENGTH = 2, i.e. 18-bit.\nUsed only when WORD_LENGTH = 3, i\nUse this bit to determine the direction of shift of …\nSet this bit to 1 to make the hardware go into the DOTCLK …\nIf this bit is set and LCDIF_MASTER bit is set, the LCDIF …\nThis field specifies how to swap the bytes fetched by the …\nLCD Data bus transfer width.\nSet this bit to make the LCDIF act as a bus master\nWhen this bit is set by software, the LCDIF will begin …\nThis bit must be set to zero to enable normal operation of …\nThe data to be transmitted is shifted left or right by …\nInput data format.\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable bus master error interrupt in …\nThis bitfield is used to show which data bytes in a 32-bit …\nThis bit is CS0/CS1 valid select signals\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to 1 enable an interrupt every time the …\nSet this bit to clear all the data in the latency FIFO …\nCommand Mode MIPI image data select bit\nSet this bit if it is required that the LCDIF block …\nIf this bit is set, the LCDIF block will assert the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an overflow interrupt in the …\nSet this bit to enable the LCDIF block to recover in the …\nThe default is to grab the odd lines first and then the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an underflow interrupt in the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an interrupt every time the …\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable bus master error interrupt in …\nThis bitfield is used to show which data bytes in a 32-bit …\nThis bit is CS0/CS1 valid select signals\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to 1 enable an interrupt every time the …\nSet this bit to clear all the data in the latency FIFO …\nCommand Mode MIPI image data select bit\nSet this bit if it is required that the LCDIF block …\nIf this bit is set, the LCDIF block will assert the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an overflow interrupt in the …\nSet this bit to enable the LCDIF block to recover in the …\nThe default is to grab the odd lines first and then the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an underflow interrupt in the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an interrupt every time the …\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable bus master error interrupt in …\nThis bitfield is used to show which data bytes in a 32-bit …\nThis bit is CS0/CS1 valid select signals\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to 1 enable an interrupt every time the …\nSet this bit to clear all the data in the latency FIFO …\nCommand Mode MIPI image data select bit\nSet this bit if it is required that the LCDIF block …\nIf this bit is set, the LCDIF block will assert the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an overflow interrupt in the …\nSet this bit to enable the LCDIF block to recover in the …\nThe default is to grab the odd lines first and then the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an underflow interrupt in the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an interrupt every time the …\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable bus master error interrupt in …\nThis bitfield is used to show which data bytes in a 32-bit …\nThis bit is CS0/CS1 valid select signals\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to 1 enable an interrupt every time the …\nSet this bit to clear all the data in the latency FIFO …\nCommand Mode MIPI image data select bit\nSet this bit if it is required that the LCDIF block …\nIf this bit is set, the LCDIF block will assert the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an overflow interrupt in the …\nSet this bit to enable the LCDIF block to recover in the …\nThe default is to grab the odd lines first and then the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an underflow interrupt in the …\nThis bit is set to indicate that an interrupt is requested …\nThis bit is set to enable an interrupt every time the …\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nNo Interrupt Request Pending.\nInterrupt Request Pending.\nBy default, when the LCDIF is in the bus master mode, it …\nThis field determines the order of the RGB components of …\nThis field determines the order of the RGB components of …\nThis bitfield indicates the maximum number of outstanding …\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nREQ_1\nREQ_16\nREQ_2\nREQ_4\nREQ_8\nBy default, when the LCDIF is in the bus master mode, it …\nThis field determines the order of the RGB components of …\nThis field determines the order of the RGB components of …\nThis bitfield indicates the maximum number of outstanding …\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nREQ_1\nREQ_16\nREQ_2\nREQ_4\nREQ_8\nBy default, when the LCDIF is in the bus master mode, it …\nThis field determines the order of the RGB components of …\nThis field determines the order of the RGB components of …\nThis bitfield indicates the maximum number of outstanding …\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nREQ_1\nREQ_16\nREQ_2\nREQ_4\nREQ_8\nBy default, when the LCDIF is in the bus master mode, it …\nThis field determines the order of the RGB components of …\nThis field determines the order of the RGB components of …\nThis bitfield indicates the maximum number of outstanding …\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nBGR\nBRG\nGBR\nGRB\nRBG\nRGB\nREQ_1\nREQ_16\nREQ_2\nREQ_4\nREQ_8\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 24 bpp format, such that all …\nData input to the block is actually RGB 18 bpp, but there …\nData to be transmitted is shifted LEFT by SHIFT_NUM_BITS …\nData to be transmitted is shifted RIGHT by SHIFT_NUM_BITS …\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\n16-bit data bus mode.\n18-bit data bus mode.\n24-bit data bus mode.\n8-bit data bus mode.\nInput data is 16 bits per pixel.\nInput data is 18 bits per pixel.\nInput data is 24 bits per pixel.\nInput data is 8 bits wide.\nWhen this bit is 0, it means that LCDIF will stop the …\nThis bit must be set to zero for normal operation\nThis field specifies how to swap the bytes after the data …\nWhen this bit is 1 and WORD_LENGTH = 0, it implies that …\nUsed only when WORD_LENGTH = 2, i.e. 18-bit.\nUsed only when WORD_LENGTH = 3, i\nUse this bit to determine the direction of shift of …\nSet this bit to 1 to make the hardware go into the DOTCLK …\nIf this bit is set and LCDIF_MASTER bit is set, the LCDIF …\nThis field specifies how to swap the bytes fetched by the …\nLCD Data bus transfer width.\nSet this bit to make the LCDIF act as a bus master\nWhen this bit is set by software, the LCDIF will begin …\nThis bit must be set to zero to enable normal operation of …\nThe data to be transmitted is shifted left or right by …\nInput data format.\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 24 bpp format, such that all …\nData input to the block is actually RGB 18 bpp, but there …\nData to be transmitted is shifted LEFT by SHIFT_NUM_BITS …\nData to be transmitted is shifted RIGHT by SHIFT_NUM_BITS …\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\n16-bit data bus mode.\n18-bit data bus mode.\n24-bit data bus mode.\n8-bit data bus mode.\nInput data is 16 bits per pixel.\nInput data is 18 bits per pixel.\nInput data is 24 bits per pixel.\nInput data is 8 bits wide.\nWhen this bit is 0, it means that LCDIF will stop the …\nThis bit must be set to zero for normal operation\nThis field specifies how to swap the bytes after the data …\nWhen this bit is 1 and WORD_LENGTH = 0, it implies that …\nUsed only when WORD_LENGTH = 2, i.e. 18-bit.\nUsed only when WORD_LENGTH = 3, i\nUse this bit to determine the direction of shift of …\nSet this bit to 1 to make the hardware go into the DOTCLK …\nIf this bit is set and LCDIF_MASTER bit is set, the LCDIF …\nThis field specifies how to swap the bytes fetched by the …\nLCD Data bus transfer width.\nSet this bit to make the LCDIF act as a bus master\nWhen this bit is set by software, the LCDIF will begin …\nThis bit must be set to zero to enable normal operation of …\nThe data to be transmitted is shifted left or right by …\nInput data format.\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 24 bpp format, such that all …\nData input to the block is actually RGB 18 bpp, but there …\nData to be transmitted is shifted LEFT by SHIFT_NUM_BITS …\nData to be transmitted is shifted RIGHT by SHIFT_NUM_BITS …\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\n16-bit data bus mode.\n18-bit data bus mode.\n24-bit data bus mode.\n8-bit data bus mode.\nInput data is 16 bits per pixel.\nInput data is 18 bits per pixel.\nInput data is 24 bits per pixel.\nInput data is 8 bits wide.\nWhen this bit is 0, it means that LCDIF will stop the …\nThis bit must be set to zero for normal operation\nThis field specifies how to swap the bytes after the data …\nWhen this bit is 1 and WORD_LENGTH = 0, it implies that …\nUsed only when WORD_LENGTH = 2, i.e. 18-bit.\nUsed only when WORD_LENGTH = 3, i\nUse this bit to determine the direction of shift of …\nSet this bit to 1 to make the hardware go into the DOTCLK …\nIf this bit is set and LCDIF_MASTER bit is set, the LCDIF …\nThis field specifies how to swap the bytes fetched by the …\nLCD Data bus transfer width.\nSet this bit to make the LCDIF act as a bus master\nWhen this bit is set by software, the LCDIF will begin …\nThis bit must be set to zero to enable normal operation of …\nThe data to be transmitted is shifted left or right by …\nInput data format.\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 18 bpp format, such that …\nData input to the block is in 24 bpp format, such that all …\nData input to the block is actually RGB 18 bpp, but there …\nData to be transmitted is shifted LEFT by SHIFT_NUM_BITS …\nData to be transmitted is shifted RIGHT by SHIFT_NUM_BITS …\nBig Endian swap (swap bytes 0,3 and 1,2).\nSwap bytes within each half-word.\nSwap half-words.\nNo byte swapping.(Little endian)\n16-bit data bus mode.\n18-bit data bus mode.\n24-bit data bus mode.\n8-bit data bus mode.\nInput data is 16 bits per pixel.\nInput data is 18 bits per pixel.\nInput data is 24 bits per pixel.\nInput data is 8 bits wide.\nAddress of the current frame being transmitted by LCDIF.\nLUT indexed address pointer\nWriting this field will load 4 bytes, aligned to four byte …\nLUT indexed address pointer\nWriting this field will load 4 bytes, aligned to four byte …\nSetting this bit will bypass the LUT memory resource …\nAddress of the next frame that will be transmitted by …\nPeriod of line counter during FD phase\nPeriod of pclk counter during LD phase\nPeriod of line counter during FD phase\nPeriod of pclk counter during LD phase\nPeriod of line counter during FD phase\nPeriod of pclk counter during LD phase\nPeriod of line counter during FD phase\nPeriod of pclk counter during LD phase\nMax cycles of frame counter\nPeriod of frame counter\nMax cycles of frame counter\nPeriod of frame counter\nMax cycles of frame counter\nPeriod of frame counter\nMax cycles of frame counter\nPeriod of frame counter\nPigeon mode dot clock gate enable\nPigeon mode data enable\nPigeon mode dot clock gate enable\nPigeon mode data enable\nPigeon mode dot clock gate enable\nPigeon mode data enable\nPigeon mode dot clock gate enable\nPigeon mode data enable\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nEnable pigeon Mode on this signal\nEvent to incrment local counter\nWhen the global counter selected through MASK_CNT_SEL …\nselect global counters as mask condition, use together …\noffset on pclk unit\nPolarity of signal output\nstate_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any …\nFrame start pulse\nLine start pulse\npclk\nUse another signal as tick event\nframe counter\nframe cycle\nhorizontal counter (pclk counter within one line )\npclk counter within one hscan state\npclk cycle within one hscan state\nvertical counter (line counter within one frame)\nline counter within one vscan state\nline cycle within one vscan state\nNormal Signal (Active high)\nInverted signal (Active low)\nFRAME BEGIN\nFRAME DATA\nFRAME END\nFRAME SYNC\nLINE BEGIN\nLINE DATA\nLINE END\nLINE SYNC\nDeassert signal output when counter match this value\nAssert signal output when counter match this value\nKeep active until mask off\nStart as active\nSelect another signal for logic operation or as mask or …\nLogic operation with another signal: DIS/AND/OR/COND\nKeep active until mask off\nsigout = sig_another AND this_sig\nNo logic operation\nmask = sig_another AND other_masks\nsigout = sig_another OR this_sig\nReflects the current state of the DMA Request line for the …\nRead only view of the current count in Latency buffer …\nRead only view of the signals that indicates LCD LFIFO is …\nRead only view of the signals that indicates LCD LFIFO is …\n0: LCDIF not present on this product 1: LCDIF is present.\nRead only view of the signals that indicates LCD TXFIFO is …\nRead only view of the signals that indicates LCD TXFIFO is …\nTotal valid data (pixels) in each horizontal line\nNumber of horizontal lines per frame which contain valid …\nDefault is data launched at negative edge of DOTCLK and …\nDefault 0 active low during valid data transfer on each …\nSetting this bit to 1 will make the hardware generate the …\nSetting this bit to 1 will make the total VSYNC period …\nWhen this bit is 0, the first field (VSYNC period) will …\nDefault 0 active low during HSYNC_PULSE_WIDTH time and …\nDefault 0 for counting VSYNC_PERIOD in terms of DISPLAY …\nDefault 0 active low during VSYNC_PULSE_WIDTH time and …\nNumber of units for which VSYNC signal is active\nDefault 0 for counting VSYNC_PULSE_WIDTH in terms of …\nDefault is data launched at negative edge of DOTCLK and …\nDefault 0 active low during valid data transfer on each …\nSetting this bit to 1 will make the hardware generate the …\nSetting this bit to 1 will make the total VSYNC period …\nWhen this bit is 0, the first field (VSYNC period) will …\nDefault 0 active low during HSYNC_PULSE_WIDTH time and …\nDefault 0 for counting VSYNC_PERIOD in terms of DISPLAY …\nDefault 0 active low during VSYNC_PULSE_WIDTH time and …\nNumber of units for which VSYNC signal is active\nDefault 0 for counting VSYNC_PULSE_WIDTH in terms of …\nDefault is data launched at negative edge of DOTCLK and …\nDefault 0 active low during valid data transfer on each …\nSetting this bit to 1 will make the hardware generate the …\nSetting this bit to 1 will make the total VSYNC period …\nWhen this bit is 0, the first field (VSYNC period) will …\nDefault 0 active low during HSYNC_PULSE_WIDTH time and …\nDefault 0 for counting VSYNC_PERIOD in terms of DISPLAY …\nDefault 0 active low during VSYNC_PULSE_WIDTH time and …\nNumber of units for which VSYNC signal is active\nDefault 0 for counting VSYNC_PULSE_WIDTH in terms of …\nDefault is data launched at negative edge of DOTCLK and …\nDefault 0 active low during valid data transfer on each …\nSetting this bit to 1 will make the hardware generate the …\nSetting this bit to 1 will make the total VSYNC period …\nWhen this bit is 0, the first field (VSYNC period) will …\nDefault 0 active low during HSYNC_PULSE_WIDTH time and …\nDefault 0 for counting VSYNC_PERIOD in terms of DISPLAY …\nDefault 0 active low during VSYNC_PULSE_WIDTH time and …\nNumber of units for which VSYNC signal is active\nDefault 0 for counting VSYNC_PULSE_WIDTH in terms of …\nTotal number of units between two positive or two negative …\nTotal number of DISPLAY CLOCK (pix_clk) cycles between two …\nNumber of DISPLAY CLOCK (pix_clk) cycles for which HSYNC …\nIn the DOTCLK mode, wait for this number of clocks from …\nWhen this bit is set, the LCDIF block will internally mux …\nIn the VSYNC interface mode, wait for this number of …\nThis bit must be set to 1 in the VSYNC mode of operation, …\nThis bitfield selects the amount of time by which the …\nTotal number of DISPLAY CLOCK (pix_clk) cycles on each …\nSet this field to 1 if the LCD controller requires that …\nLPI2C\nLPI2C\nLPI2C\nLPI2C\nMaster Clock Configuration Register 0\nMaster Clock Configuration Register 0\nMaster Clock Configuration Register 1\nMaster Clock Configuration Register 1\nMaster Configuration Register 0\nMaster Configuration Register 0\nMaster Configuration Register 1\nMaster Configuration Register 1\nMaster Configuration Register 2\nMaster Configuration Register 2\nMaster Configuration Register 3\nMaster Configuration Register 3\nMaster Control Register\nMaster Control Register\nMaster DMA Enable Register\nMaster DMA Enable Register\nMaster Data Match Register\nMaster Data Match Register\nMaster FIFO Control Register\nMaster FIFO Control Register\nMaster FIFO Status Register\nMaster FIFO Status Register\nMaster Interrupt Enable Register\nMaster Interrupt Enable Register\nMaster Receive Data Register\nMaster Receive Data Register\nMaster Status Register\nMaster Status Register\nMaster Transmit Data Register\nMaster Transmit Data Register\nParameter Register\nParameter Register\nLPI2C\nSlave Address Match Register\nSlave Address Match Register\nSlave Address Status Register\nSlave Address Status Register\nSlave Configuration Register 1\nSlave Configuration Register 1\nSlave Configuration Register 2\nSlave Configuration Register 2\nSlave Control Register\nSlave Control Register\nSlave DMA Enable Register\nSlave DMA Enable Register\nSlave Interrupt Enable Register\nSlave Interrupt Enable Register\nSlave Receive Data Register\nSlave Receive Data Register\nSlave Status Register\nSlave Status Register\nSlave Transmit ACK Register\nSlave Transmit ACK Register\nSlave Transmit Data Register\nSlave Transmit Data Register\nVersion ID Register\nVersion ID Register\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nClock High Period\nClock Low Period\nData Valid Delay\nSetup Hold Delay\nClock High Period\nClock Low Period\nData Valid Delay\nSetup Hold Delay\nCircular FIFO Enable\nHost Request Enable\nHost Request Polarity\nHost Request Select\nReceive Data Match Only\nCircular FIFO is disabled\nCircular FIFO is enabled\nHost request input is disabled\nHost request input is enabled\nActive low\nActive high\nHost request input is pin HREQ\nHost request input is input trigger\nReceived data is stored in the receive FIFO\nReceived data is discarded unless the the Data Match Flag …\nAutomatic STOP Generation\nIGNACK\nMatch Configuration\nPin Configuration\nPrescaler\nTimeout Configuration\nNo effect\nSTOP condition is automatically generated whenever the …\nLPI2C Master will receive ACK and NACK normally\nLPI2C Master will treat a received NACK as if it (NACK) …\nMatch is disabled\nMatch is enabled (1st data word equals MATCH0 OR MATCH1)\nMatch is enabled (any data word equals MATCH0 OR MATCH1)\nMatch is enabled (1st data word equals MATCH0 AND 2nd data …\nMatch is enabled (any data word equals MATCH0 AND next …\nMatch is enabled (1st data word AND MATCH1 equals MATCH0 …\nMatch is enabled (any data word AND MATCH1 equals MATCH0 …\n2-pin open drain mode\n2-pin output only mode (ultra-fast mode)\n2-pin push-pull mode\n4-pin push-pull mode\n2-pin open drain mode with separate LPI2C slave\n2-pin output only mode (ultra-fast mode) with separate …\n2-pin push-pull mode with separate LPI2C slave\n4-pin push-pull mode (inverted outputs)\nDivide by 1\nDivide by 2\nDivide by 4\nDivide by 8\nDivide by 16\nDivide by 32\nDivide by 64\nDivide by 128\nPin Low Timeout Flag will set if SCL is low for longer …\nPin Low Timeout Flag will set if either SCL or SDA is low …\nBus Idle Timeout\nGlitch Filter SCL\nGlitch Filter SDA\nPin Low Timeout\nDebug Enable\nDoze mode enable\nMaster Enable\nReset Receive FIFO\nSoftware Reset\nReset Transmit FIFO\nMaster is disabled in debug mode\nMaster is enabled in debug mode\nMaster is enabled in Doze mode\nMaster is disabled in Doze mode\nMaster logic is disabled\nMaster logic is enabled\nNo effect\nReceive FIFO is reset\nMaster logic is not reset\nMaster logic is reset\nNo effect\nTransmit FIFO is reset\nReceive Data DMA Enable\nTransmit Data DMA Enable\nDMA request is disabled\nDMA request is enabled\nDMA request is disabled\nDMA request is enabled\nMatch 0 Value\nMatch 1 Value\nReceive FIFO Watermark\nTransmit FIFO Watermark\nReceive FIFO Count\nTransmit FIFO Count\nArbitration Lost Interrupt Enable\nData Match Interrupt Enable\nEnd Packet Interrupt Enable\nFIFO Error Interrupt Enable\nNACK Detect Interrupt Enable\nPin Low Timeout Interrupt Enable\nReceive Data Interrupt Enable\nSTOP Detect Interrupt Enable\nTransmit Data Interrupt Enable\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nEnabled\nDisabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nReceive Data\nRX Empty\nReceive FIFO is not empty\nReceive FIFO is empty\nArbitration Lost Flag\nBus Busy Flag\nData Match Flag\nEnd Packet Flag\nFIFO Error Flag\nMaster Busy Flag\nNACK Detect Flag\nPin Low Timeout Flag\nReceive Data Flag\nSTOP Detect Flag\nTransmit Data Flag\nMaster has not lost arbitration\nMaster has lost arbitration\nI2C Bus is idle\nI2C Bus is busy\nHave not received matching data\nHave received matching data\nMaster has not generated a STOP or Repeated START condition\nMaster has generated a STOP or Repeated START condition\nNo error\nMaster sending or receiving data without a START condition\nI2C Master is idle\nI2C Master is busy\nUnexpected NACK was not detected\nUnexpected NACK was detected\nPin low timeout has not occurred or is disabled\nPin low timeout has occurred\nReceive Data is not ready\nReceive data is ready\nMaster has not generated a STOP condition\nMaster has generated a STOP condition\nTransmit data is not requested\nTransmit data is requested\nCommand Data\nTransmit Data\nTransmit DATA[7:0]\nReceive (DATA[7:0] + 1) bytes\nGenerate STOP condition\nReceive and discard (DATA[7:0] + 1) bytes\nGenerate (repeated) START and transmit address in DATA[7:0]\nGenerate (repeated) START and transmit address in DATA[7:0…\nGenerate (repeated) START and transmit address in DATA[7:0…\nGenerate (repeated) START and transmit address in DATA[7:0…\nMaster Receive FIFO Size\nMaster Transmit FIFO Size\nAddress 0 Value\nAddress 1 Value\nAddress Not Valid\nReceived Address\nReceived Address (RADDR) is valid\nReceived Address (RADDR) is not valid\nACK SCL Stall\nAddress Configuration\nAddress SCL Stall\nGeneral Call Enable\nHigh Speed Mode Enable\nIgnore NACK\nReceive Data Configuration\nRX SCL Stall\nSMBus Alert Enable\nTransmit Flag Configuration\nTX Data SCL Stall\nClock stretching is disabled\nClock stretching is enabled\nAddress match 0 (7-bit)\nAddress match 0 (10-bit)\nAddress match 0 (7-bit) or Address match 1 (7-bit)\nAddress match 0 (10-bit) or Address match 1 (10-bit)\nAddress match 0 (7-bit) or Address match 1 (10-bit)\nAddress match 0 (10-bit) or Address match 1 (7-bit)\nFrom Address match 0 (7-bit) to Address match 1 (7-bit)\nFrom Address match 0 (10-bit) to Address match 1 (10-bit)\nClock stretching is disabled\nClock stretching is enabled\nGeneral Call address is disabled\nGeneral Call address is enabled\nDisables detection of HS-mode master code\nEnables detection of HS-mode master code\nSlave will end transfer when NACK is detected\nSlave will not end transfer when NACK detected\nReading the Receive Data register will return received …\nReading the Receive Data register when the Address Valid …\nClock stretching is disabled\nClock stretching is enabled\nDisables match on SMBus Alert\nEnables match on SMBus Alert\nTransmit Data Flag will only assert during a …\nTransmit Data Flag will assert whenever the Transmit Data …\nClock stretching is disabled\nClock stretching is enabled\nClock Hold Time\nData Valid Delay\nGlitch Filter SCL\nGlitch Filter SDA\nFilter Doze Enable\nFilter Enable\nReset Receive FIFO\nSoftware Reset\nReset Transmit FIFO\nSlave Enable\nFilter remains enabled in Doze mode\nFilter is disabled in Doze mode\nDisable digital filter and output delay counter for slave …\nEnable digital filter and output delay counter for slave …\nNo effect\nReceive Data Register is now empty\nSlave mode logic is not reset\nSlave mode logic is reset\nNo effect\nTransmit Data Register is now empty\nI2C Slave mode is disabled\nI2C Slave mode is enabled\nAddress Valid DMA Enable\nReceive Data DMA Enable\nTransmit Data DMA Enable\nDMA request is disabled\nDMA request is enabled\nDMA request is disabled\nDMA request is enabled\nDMA request is disabled\nDMA request is enabled\nAddress Match 0 Interrupt Enable\nAddress Match 1 Interrupt Enable\nAddress Valid Interrupt Enable\nBit Error Interrupt Enable\nFIFO Error Interrupt Enable\nGeneral Call Interrupt Enable\nReceive Data Interrupt Enable\nRepeated Start Interrupt Enable\nSMBus Alert Response Interrupt Enable\nSTOP Detect Interrupt Enable\nTransmit ACK Interrupt Enable\nTransmit Data Interrupt Enable\nEnabled\nDisabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nReceive Data\nRX Empty\nStart Of Frame\nThe Receive Data Register is not empty\nThe Receive Data Register is empty\nIndicates this is not the first data word since a …\nIndicates this is the first data word since a (repeated) …\nAddress Match 0 Flag\nAddress Match 1 Flag\nAddress Valid Flag\nBus Busy Flag\nBit Error Flag\nFIFO Error Flag\nGeneral Call Flag\nReceive Data Flag\nRepeated Start Flag\nSMBus Alert Response Flag\nSlave Busy Flag\nSTOP Detect Flag\nTransmit ACK Flag\nTransmit Data Flag\nHave not received an ADDR0 matching address\nHave received an ADDR0 matching address\nHave not received an ADDR1 or ADDR0/ADDR1 range matching …\nHave received an ADDR1 or ADDR0/ADDR1 range matching …\nAddress Status Register is not valid\nAddress Status Register is valid\nI2C Bus is idle\nI2C Bus is busy\nSlave has not detected a bit error\nSlave has detected a bit error\nFIFO underflow or overflow was not detected\nFIFO underflow or overflow was detected\nSlave has not detected the General Call Address or the …\nSlave has detected the General Call Address\nReceive data is not ready\nReceive data is ready\nSlave has not detected a Repeated START condition\nSlave has detected a Repeated START condition\nSMBus Alert Response is disabled or not detected\nSMBus Alert Response is enabled and detected\nI2C Slave is idle\nI2C Slave is busy\nSlave has not detected a STOP condition\nSlave has detected a STOP condition\nTransmit ACK/NACK is not required\nTransmit ACK/NACK is required\nTransmit data not requested\nTransmit data is requested\nTransmit NACK\nWrite a Transmit ACK for each received word\nWrite a Transmit NACK for each received word\nTransmit Data\nFeature Specification Number\nMajor Version Number\nMinor Version Number\nMaster only, with standard feature set\nMaster and slave, with standard feature set\nClock Configuration Register\nClock Configuration Register\nConfiguration Register 0\nConfiguration Register 0\nConfiguration Register 1\nConfiguration Register 1\nControl Register\nControl Register\nDMA Enable Register\nDMA Enable Register\nData Match Register 0\nData Match Register 0\nData Match Register 1\nData Match Register 1\nFIFO Control Register\nFIFO Control Register\nFIFO Status Register\nFIFO Status Register\nInterrupt Enable Register\nInterrupt Enable Register\nLPSPI\nLPSPI\nLPSPI\nLPSPI\nParameter Register\nParameter Register\nReceive Data Register\nReceive Data Register\nReceive Status Register\nReceive Status Register\nLPSPI\nStatus Register\nStatus Register\nTransmit Command Register\nTransmit Command Register\nTransmit Data Register\nTransmit Data Register\nVersion ID Register\nVersion ID Register\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nDelay Between Transfers\nPCS-to-SCK Delay\nSCK Divider\nSCK-to-PCS Delay\nCircular FIFO Enable\nHost Request Enable\nHost Request Polarity\nHost Request Select\nReceive Data Match Only\nCircular FIFO is disabled\nCircular FIFO is enabled\nReceived data is stored in the receive FIFO as in normal …\nReceived data is discarded unless the Data Match Flag …\nAutomatic PCS\nMaster Mode\nMatch Configuration\nNo Stall\nOutput Config\nPeripheral Chip Select Configuration\nPeripheral Chip Select Polarity\nPin Configuration\nSample Point\nAutomatic PCS generation is disabled\nAutomatic PCS generation is enabled\nSlave mode\nMaster mode\nMatch is disabled\n010b - Match is enabled, if 1st data word equals MATCH0 OR …\n011b - Match is enabled, if any data word equals MATCH0 OR …\n100b - Match is enabled, if 1st data word equals MATCH0 …\n101b - Match is enabled, if any data word equals MATCH0 …\n110b - Match is enabled, if (1st data word AND MATCH1) …\n111b - Match is enabled, if (any data word AND MATCH1) …\nTransfers will stall when the transmit FIFO is empty or …\nTransfers will not stall, allowing transmit FIFO underruns …\nOutput data retains last value when chip select is negated\nOutput data is tristated when chip select is negated\nPCS[3:2] are enabled\nPCS[3:2] are disabled\nSIN is used for input data and SOUT is used for output data\nSIN is used for both input and output data\nSOUT is used for both input and output data\nSOUT is used for input data and SIN is used for output data\nInput data is sampled on SCK edge\nInput data is sampled on delayed SCK edge\nDebug Enable\nDoze Mode Enable\nModule Enable\nReset Receive FIFO\nSoftware Reset\nReset Transmit FIFO\nLPSPI module is disabled in debug mode\nLPSPI module is enabled in debug mode\nLPSPI module is enabled in Doze mode\nLPSPI module is disabled in Doze mode\nModule is disabled\nModule is enabled\nNo effect\nReceive FIFO is reset\nModule is not reset\nModule is reset\nNo effect\nTransmit FIFO is reset\nReceive Data DMA Enable\nTransmit Data DMA Enable\nDMA request is disabled\nDMA request is enabled\nDMA request is disabled\nDMA request is enabled\nMatch 0 Value\nMatch 1 Value\nReceive FIFO Watermark\nTransmit FIFO Watermark\nReceive FIFO Count\nTransmit FIFO Count\nData Match Interrupt Enable\nFrame Complete Interrupt Enable\nReceive Data Interrupt Enable\nReceive Error Interrupt Enable\nTransfer Complete Interrupt Enable\nTransmit Data Interrupt Enable\nTransmit Error Interrupt Enable\nWord Complete Interrupt Enable\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nDisabled\nEnabled\nPCS Number\nReceive FIFO Size\nTransmit FIFO Size\nReceive Data\nRX FIFO Empty\nStart Of Frame\nRX FIFO is not empty\nRX FIFO is empty\nSubsequent data word received after LPSPI_PCS assertion\nFirst data word received after LPSPI_PCS assertion\nData Match Flag\nFrame Complete Flag\nModule Busy Flag\nReceive Data Flag\nReceive Error Flag\nTransfer Complete Flag\nTransmit Data Flag\nTransmit Error Flag\nWord Complete Flag\nHave not received matching data\nHave received matching data\nFrame transfer has not completed\nFrame transfer has completed\nLPSPI is idle\nLPSPI is busy\nReceive Data is not ready\nReceive data is ready\nReceive FIFO has not overflowed\nReceive FIFO has overflowed\nAll transfers have not completed\nAll transfers have completed\nTransmit data not requested\nTransmit data is requested\nTransmit FIFO underrun has not occurred\nTransmit FIFO underrun has occurred\nTransfer of a received word has not yet completed\nTransfer of a received word has completed\nByte Swap\nContinuous Transfer\nContinuing Command\nClock Phase\nClock Polarity\nFrame Size\nLSB First\nPeripheral Chip Select\nPrescaler Value\nReceive Data Mask\nTransmit Data Mask\nTransfer Width\nByte swap is disabled\nByte swap is enabled\nContinuous transfer is disabled\nContinuous transfer is enabled\nCommand word for start of new transfer\nCommand word for continuing transfer\nData is captured on the leading edge of SCK and changed on …\nData is changed on the leading edge of SCK and captured on …\nThe inactive state value of SCK is low\nThe inactive state value of SCK is high\nData is transferred MSB first\nData is transferred LSB first\nTransfer using LPSPI_PCS[0]\nTransfer using LPSPI_PCS[1]\nTransfer using LPSPI_PCS[2]\nTransfer using LPSPI_PCS[3]\nDivide by 1\nDivide by 2\nDivide by 4\nDivide by 8\nDivide by 16\nDivide by 32\nDivide by 64\nDivide by 128\nNormal transfer\nReceive data is masked\nNormal transfer\nMask transmit data\n1 bit transfer\n2 bit transfer\n4 bit transfer\nTransmit Data\nModule Identification Number\nMajor Version Number\nMinor Version Number\nStandard feature set supporting a 32-bit shift register.\nLPUART Baud Rate Register\nLPUART Baud Rate Register\nLPUART Control Register\nLPUART Control Register\nLPUART Data Register\nLPUART Data Register\nLPUART FIFO Register\nLPUART FIFO Register\nLPUART Global Register\nLPUART Global Register\nLPUART\nLPUART\nLPUART\nLPUART\nLPUART\nLPUART\nLPUART\nLPUART\nLPUART Match Address Register\nLPUART Match Address Register\nLPUART Modem IrDA Register\nLPUART Modem IrDA Register\nParameter Register\nParameter Register\nLPUART Pin Configuration Register\nLPUART Pin Configuration Register\nLPUART\nLPUART Status Register\nLPUART Status Register\nVersion ID Register\nVersion ID Register\nLPUART Watermark Register\nLPUART Watermark Register\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nBoth Edge Sampling\nLIN Break Detect Interrupt Enable\n10-bit Mode select\nMatch Address Mode Enable 1\nMatch Address Mode Enable 2\nMatch Configuration\nOversampling Ratio\nReceiver Full DMA Enable\nResynchronization Disable\nReceiver Idle DMA Enable\nRX Input Active Edge Interrupt Enable\nStop Bit Number Select\nBaud Rate Modulo Divisor.\nTransmitter DMA Enable\nReceiver samples input data using the rising edge of the …\nReceiver samples input data using the rising and falling …\nHardware interrupts from STAT[LBKDIF] flag are disabled …\nHardware interrupt requested when STAT[LBKDIF] flag is 1.\nReceiver and transmitter use 7-bit to 9-bit data …\nReceiver and transmitter use 10-bit data characters.\nNormal operation.\nEnables automatic address matching or data matching mode …\nNormal operation.\nEnables automatic address matching or data matching mode …\nAddress Match Wakeup\nIdle Match Wakeup\nMatch On and Match Off\nEnables RWU on Data Match and Match On/Off for transmitter …\nWriting 0 to this field will result in an oversampling …\nOversampling ratio of 11.\nOversampling ratio of 12.\nOversampling ratio of 13.\nOversampling ratio of 14.\nOversampling ratio of 15.\nOversampling ratio of 16.\nOversampling ratio of 17.\nOversampling ratio of 18.\nOversampling ratio of 19.\nOversampling ratio of 20.\nOversampling ratio of 21.\nOversampling ratio of 22.\nOversampling ratio of 23.\nOversampling ratio of 24.\nOversampling ratio of 25.\nOversampling ratio of 26.\nOversampling ratio of 27.\nOversampling ratio of 28.\nOversampling ratio of 29.\nOversampling ratio of 30.\nOversampling ratio of 4, requires BOTHEDGE to be set.\nOversampling ratio of 31.\nOversampling ratio of 32.\nOversampling ratio of 5, requires BOTHEDGE to be set.\nOversampling ratio of 6, requires BOTHEDGE to be set.\nOversampling ratio of 7, requires BOTHEDGE to be set.\nOversampling ratio of 8.\nOversampling ratio of 9.\nOversampling ratio of 10.\nDMA request disabled.\nDMA request enabled.\nResynchronization during received data word is supported\nResynchronization during received data word is disabled\nDMA request disabled.\nDMA request enabled.\nHardware interrupts from STAT[RXEDGIF] are disabled.\nHardware interrupt is requested when STAT[RXEDGIF] flag is …\nOne stop bit.\nTwo stop bits.\nDMA request disabled.\nDMA request enabled.\nDoze Enable\nFraming Error Interrupt Enable\nIdle Configuration\nIdle Line Interrupt Enable\nIdle Line Type Select\nLoop Mode Select\n9-Bit or 8-Bit Mode Select\n7-Bit Mode Select\nMatch 1 Interrupt Enable\nMatch 2 Interrupt Enable\nNoise Error Interrupt Enable\nOverrun Interrupt Enable\nParity Enable\nParity Error Interrupt Enable\nParity Type\nReceive Bit 8 / Transmit Bit 9\nReceive Bit 9 / Transmit Bit 8\nReceiver Enable\nReceiver Interrupt Enable\nReceiver Source Select\nReceiver Wakeup Control\nSend Break\nTransmission Complete Interrupt Enable for\nTransmitter Enable\nTransmit Interrupt Enable\nTXD Pin Direction in Single-Wire Mode\nTransmit Data Inversion\nReceiver Wakeup Method Select\nLPUART is enabled in Doze mode.\nLPUART is disabled in Doze mode.\nFE interrupts disabled; use polling.\nHardware interrupt requested when FE is set.\n1 idle character\n2 idle characters\n4 idle characters\n8 idle characters\n16 idle characters\n32 idle characters\n64 idle characters\n128 idle characters\nHardware interrupts from IDLE disabled; use polling.\nHardware interrupt requested when IDLE flag is 1.\nIdle character bit count starts after start bit.\nIdle character bit count starts after stop bit.\nNormal operation - RXD and TXD use separate pins.\nLoop mode or single-wire mode where transmitter outputs …\nReceiver and transmitter use 8-bit to 10-bit data …\nReceiver and transmitter use 7-bit data characters.\nReceiver and transmitter use 8-bit data characters.\nReceiver and transmitter use 9-bit data characters.\nMA1F interrupt disabled\nMA1F interrupt enabled\nMA2F interrupt disabled\nMA2F interrupt enabled\nNF interrupts disabled; use polling.\nHardware interrupt requested when NF is set.\nOR interrupts disabled; use polling.\nHardware interrupt requested when OR is set.\nNo hardware parity generation or checking.\nParity enabled.\nPF interrupts disabled; use polling).\nHardware interrupt requested when PF is set.\nEven parity.\nOdd parity.\nReceiver disabled.\nReceiver enabled.\nHardware interrupts from RDRF disabled; use polling.\nHardware interrupt requested when RDRF flag is 1.\nProvided LOOPS is set, RSRC is cleared, selects internal …\nSingle-wire LPUART mode where the TXD pin is connected to …\nNormal receiver operation.\nLPUART receiver in standby waiting for wakeup condition.\nNormal transmitter operation.\nQueue break character(s) to be sent.\nHardware interrupts from TC disabled; use polling.\nHardware interrupt requested when TC flag is 1.\nTransmitter disabled.\nTransmitter enabled.\nHardware interrupts from TDRE disabled; use polling.\nHardware interrupt requested when TDRE flag is 1.\nTXD pin is an input in single-wire mode.\nTXD pin is an output in single-wire mode.\nTransmit data not inverted.\nTransmit data inverted.\nConfigures RWU for idle-line wakeup.\nConfigures RWU with address-mark wakeup.\nFrame Error / Transmit Special Character\nIdle Line\nNOISY\nPARITYE\nR0T0\nR1T1\nR2T2\nR3T3\nR4T4\nR5T5\nR6T6\nR7T7\nR8T8\nR9T9\nReceive Buffer Empty\nThe dataword was received without a frame error on read, …\nThe dataword was received with a frame error, or transmit …\nReceiver was not idle before receiving this character.\nReceiver was idle before receiving this character.\nThe dataword was received without noise.\nThe data was received with noise.\nThe dataword was received without a parity error.\nThe dataword was received with a parity error.\nReceive buffer contains valid data.\nReceive buffer is empty, data returned on read is not …\nReceive Buffer/FIFO Empty\nReceive FIFO Enable\nReceive FIFO Buffer Depth\nReceive FIFO/Buffer Flush\nReceiver Idle Empty Enable\nReceiver Buffer Underflow Flag\nReceive FIFO Underflow Interrupt Enable\nTransmit Buffer/FIFO Empty\nTransmit FIFO Enable\nTransmit FIFO Buffer Depth\nTransmit FIFO/Buffer Flush\nTransmitter Buffer Overflow Flag\nTransmit FIFO Overflow Interrupt Enable\nReceive buffer is not empty.\nReceive buffer is empty.\nReceive FIFO is not enabled. Buffer is depth 1.\nReceive FIFO is enabled. Buffer is depth indicted by …\nReceive FIFO/Buffer depth = 1 dataword.\nReceive FIFO/Buffer depth = 4 datawords.\nReceive FIFO/Buffer depth = 8 datawords.\nReceive FIFO/Buffer depth = 16 datawords.\nReceive FIFO/Buffer depth = 32 datawords.\nReceive FIFO/Buffer depth = 64 datawords.\nReceive FIFO/Buffer depth = 128 datawords.\nReceive FIFO/Buffer depth = 256 datawords.\nNo flush operation occurs.\nAll data in the receive FIFO/buffer is cleared out.\nDisable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nEnable RDRF assertion due to partially filled FIFO when …\nNo receive buffer underflow has occurred since the last …\nAt least one receive buffer underflow has occurred since …\nRXUF flag does not generate an interrupt to the host.\nRXUF flag generates an interrupt to the host.\nTransmit buffer is not empty.\nTransmit buffer is empty.\nTransmit FIFO is not enabled. Buffer is depth 1.\nTransmit FIFO is enabled. Buffer is depth indicated by …\nTransmit FIFO/Buffer depth = 1 dataword.\nTransmit FIFO/Buffer depth = 4 datawords.\nTransmit FIFO/Buffer depth = 8 datawords.\nTransmit FIFO/Buffer depth = 16 datawords.\nTransmit FIFO/Buffer depth = 32 datawords.\nTransmit FIFO/Buffer depth = 64 datawords.\nTransmit FIFO/Buffer depth = 128 datawords.\nTransmit FIFO/Buffer depth = 256 datawords\nNo flush operation occurs.\nAll data in the transmit FIFO/Buffer is cleared out.\nNo transmit buffer overflow has occurred since the last …\nAt least one transmit buffer overflow has occurred since …\nTXOF flag does not generate an interrupt to the host.\nTXOF flag generates an interrupt to the host.\nSoftware Reset\nModule is not reset.\nModule is reset.\nMatch Address 1\nMatch Address 2\nInfrared enable\nReceive RTS Configuration\nReceiver request-to-send enable\nTransmitter narrow pulse\nTransmit CTS Configuration\nTransmitter clear-to-send enable\nTransmit CTS Source\nTransmitter request-to-send enable\nTransmitter request-to-send polarity\nIR disabled.\nIR enabled.\nThe receiver has no effect on RTS.\nRTS is deasserted if the receiver data register is full or …\n1/OSR.\n2/OSR.\n3/OSR.\n4/OSR.\nCTS input is sampled at the start of each character.\nCTS input is sampled when the transmitter is idle.\nCTS has no effect on the transmitter.\nEnables clear-to-send operation. The transmitter checks …\nCTS input is the CTS_B pin.\nCTS input is the inverted Receiver Match result.\nThe transmitter has no effect on RTS.\nWhen a character is placed into an empty transmitter data …\nTransmitter RTS is active low.\nTransmitter RTS is active high.\nReceive FIFO Size\nTransmit FIFO Size\nTrigger Select\nInput trigger is disabled.\nInput trigger is used instead of RXD pin input.\nInput trigger is used instead of CTS_B pin input.\nInput trigger is used to modulate the TXD pin output. The …\nBreak Character Generation Length\nFraming Error Flag\nIdle Line Flag\nLIN Break Detection Enable\nLIN Break Detect Interrupt Flag\nMatch 1 Flag\nMatch 2 Flag\nMSB First\nNoise Flag\nReceiver Overrun Flag\nParity Error Flag\nReceiver Active Flag\nReceive Data Register Full Flag\nReceive Wake Up Idle Detect\nRXD Pin Active Edge Interrupt Flag\nReceive Data Inversion\nTransmission Complete Flag\nTransmit Data Register Empty Flag\nBreak character is transmitted with length of 9 to 13 bit …\nBreak character is transmitted with length of 12 to 15 bit …\nNo framing error detected. This does not guarantee the …\nFraming error.\nNo idle line detected.\nIdle line was detected.\nLIN break detect is disabled, normal break character can …\nLIN break detect is enabled. LIN break character is …\nNo LIN break character has been detected.\nLIN break character has been detected.\nReceived data is not equal to MA1\nReceived data is equal to MA1\nReceived data is not equal to MA2\nReceived data is equal to MA2\nLSB (bit0) is the first bit that is transmitted following …\nMSB (bit9, bit8, bit7 or bit6) is the first bit that is …\nNo noise detected.\nNoise detected in the received character in the DATA …\nNo overrun.\nReceive overrun (new LPUART data lost).\nNo parity error.\nParity error.\nLPUART receiver idle waiting for a start bit.\nLPUART receiver active (RXD input not idle).\nReceive data buffer empty.\nReceive data buffer full.\nDuring receive standby state (RWU = 1), the IDLE bit does …\nDuring receive standby state (RWU = 1), the IDLE bit gets …\nNo active edge on the receive pin has occurred.\nAn active edge on the receive pin has occurred.\nReceive data not inverted.\nReceive data inverted.\nTransmitter active (sending data, a preamble, or a break).\nTransmitter idle (transmission activity complete).\nTransmit data buffer full.\nTransmit data buffer empty.\nFeature Identification Number\nMajor Version Number\nMinor Version Number\nStandard feature set.\nStandard feature set with MODEM/IrDA support.\nReceive Counter\nReceive Watermark\nTransmit Counter\nTransmit Watermark\nValue of OTP Bank1 Word5 (Memory Related Info.)\nValue of OTP Bank1 Word5 (Memory Related Info.)\nValue of OTP Bank1 Word6 (General Purpose Customer Defined …\nValue of OTP Bank1 Word6 (General Purpose Customer Defined …\nValue of OTP Bank1 Word7 (General Purpose Customer Defined …\nValue of OTP Bank1 Word7 (General Purpose Customer Defined …\nValue of OTP Bank0 Word1 (Configuration and Manufacturing …\nValue of OTP Bank0 Word1 (Configuration and Manufacturing …\nValue of OTP Bank0 Word2 (Configuration and Manufacturing …\nValue of OTP Bank0 Word2 (Configuration and Manufacturing …\nValue of OTP Bank0 Word3 (Configuration and Manufacturing …\nValue of OTP Bank0 Word3 (Configuration and Manufacturing …\nValue of OTP Bank0 Word4 (Configuration and Manufacturing …\nValue of OTP Bank0 Word4 (Configuration and Manufacturing …\nValue of OTP Bank0 Word5 (Configuration and Manufacturing …\nValue of OTP Bank0 Word5 (Configuration and Manufacturing …\nValue of OTP Bank0 Word6 (Configuration and Manufacturing …\nValue of OTP Bank0 Word6 (Configuration and Manufacturing …\nValue of OTP Bank0 Word7 (Configuration and Manufacturing …\nValue of OTP Bank0 Word7 (Configuration and Manufacturing …\nOTP Controller CRC test address\nOTP Controller CRC test address\nOTP Controller CRC Value Register\nOTP Controller CRC Value Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Control Register\nOTP Controller Write Data Register\nOTP Controller Write Data Register\nValue of OTP Bank4 Word6 (General Purpose Customer Defined …\nValue of OTP Bank4 Word6 (General Purpose Customer Defined …\nValue of OTP Bank4 Word7 (General Purpose Customer Defined …\nValue of OTP Bank4 Word7 (General Purpose Customer Defined …\nValue of OTP Bank7 Word0 (GP3)\nValue of OTP Bank7 Word0 (GP3)\nValue of OTP Bank7 Word1 (GP3)\nValue of OTP Bank7 Word1 (GP3)\nValue of OTP Bank7 Word2 (GP3)\nValue of OTP Bank7 Word2 (GP3)\nValue of OTP Bank7 Word3 (GP3)\nValue of OTP Bank7 Word3 (GP3)\nValue of OTP Bank7 Word4 (GP4)\nValue of OTP Bank7 Word4 (GP4)\nValue of OTP Bank7 Word5 (GP4)\nValue of OTP Bank7 Word5 (GP4)\nValue of OTP Bank7 Word6 (GP4)\nValue of OTP Bank7 Word6 (GP4)\nValue of OTP Bank7 Word7 (GP4)\nValue of OTP Bank7 Word7 (GP4)\nValue of OTP Bank0 Word0 (Lock controls)\nValue of OTP Bank0 Word0 (Lock controls)\nValue of OTP Bank4 Word2 (MAC Address)\nValue of OTP Bank4 Word2 (MAC Address)\nValue of OTP Bank4 Word3 (MAC Address)\nValue of OTP Bank4 Word3 (MAC Address)\nValue of OTP Bank4 Word4 (MAC2 Address)\nValue of OTP Bank4 Word4 (MAC2 Address)\nValue of OTP Bank1 Word0 (Memory Related Info.)\nValue of OTP Bank1 Word0 (Memory Related Info.)\nValue of OTP Bank1 Word1 (Memory Related Info.)\nValue of OTP Bank1 Word1 (Memory Related Info.)\nValue of OTP Bank1 Word2 (Memory Related Info.)\nValue of OTP Bank1 Word2 (Memory Related Info.)\nValue of OTP Bank1 Word3 (Memory Related Info.)\nValue of OTP Bank1 Word3 (Memory Related Info.)\nValue of OTP Bank1 Word4 (Memory Related Info.)\nValue of OTP Bank1 Word4 (Memory Related Info.)\nValue of OTP Bank5 Word5 (Misc Conf)\nValue of OTP Bank5 Word5 (Misc Conf)\nValue of OTP Bank5 Word6 (Misc Conf)\nValue of OTP Bank5 Word6 (Misc Conf)\nOCOTP\nValue of OTP Bank2 Word0 (OTPMK Key)\nValue of OTP Bank2 Word0 (OTPMK Key)\nValue of OTP Bank2 Word1 (OTPMK Key)\nValue of OTP Bank2 Word1 (OTPMK Key)\nValue of OTP Bank2 Word2 (OTPMK Key)\nValue of OTP Bank2 Word2 (OTPMK Key)\nValue of OTP Bank2 Word3 (OTPMK Key)\nValue of OTP Bank2 Word3 (OTPMK Key)\nValue of OTP Bank2 Word4 (OTPMK Key)\nValue of OTP Bank2 Word4 (OTPMK Key)\nValue of OTP Bank2 Word5 (OTPMK Key)\nValue of OTP Bank2 Word5 (OTPMK Key)\nValue of OTP Bank2 Word6 (OTPMK Key)\nValue of OTP Bank2 Word6 (OTPMK Key)\nValue of OTP Bank2 Word7 (OTPMK Key)\nValue of OTP Bank2 Word7 (OTPMK Key)\nValue of OTP Bank4 Word5 (CRC Key)\nValue of OTP Bank4 Word5 (CRC Key)\nOTP Controller Write Data Register\nOTP Controller Write Data Register\nOTP Controller Read Data Register\nOTP Controller Read Data Register\nValue of OTP Bank6 Word0 (ROM Patch)\nValue of OTP Bank6 Word0 (ROM Patch)\nValue of OTP Bank6 Word1 (ROM Patch)\nValue of OTP Bank6 Word1 (ROM Patch)\nValue of OTP Bank6 Word2 (ROM Patch)\nValue of OTP Bank6 Word2 (ROM Patch)\nValue of OTP Bank6 Word3 (ROM Patch)\nValue of OTP Bank6 Word3 (ROM Patch)\nValue of OTP Bank6 Word4 (ROM Patch)\nValue of OTP Bank6 Word4 (ROM Patch)\nValue of OTP Bank6 Word5 (ROM Patch)\nValue of OTP Bank6 Word5 (ROM Patch)\nValue of OTP Bank6 Word6 (ROM Patch)\nValue of OTP Bank6 Word6 (ROM Patch)\nValue of OTP Bank6 Word7 (ROM Patch)\nValue of OTP Bank6 Word7 (ROM Patch)\nOCOTP\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nSoftware Controllable Signals Register\nValue of OTP Bank4 Word0 (Secure JTAG Response Field)\nValue of OTP Bank4 Word0 (Secure JTAG Response Field)\nValue of OTP Bank4 Word1 (Secure JTAG Response Field)\nValue of OTP Bank4 Word1 (Secure JTAG Response Field)\nShadow Register for OTP Bank3 Word0 (SRK Hash)\nShadow Register for OTP Bank3 Word0 (SRK Hash)\nShadow Register for OTP Bank3 Word1 (SRK Hash)\nShadow Register for OTP Bank3 Word1 (SRK Hash)\nShadow Register for OTP Bank3 Word2 (SRK Hash)\nShadow Register for OTP Bank3 Word2 (SRK Hash)\nShadow Register for OTP Bank3 Word3 (SRK Hash)\nShadow Register for OTP Bank3 Word3 (SRK Hash)\nShadow Register for OTP Bank3 Word4 (SRK Hash)\nShadow Register for OTP Bank3 Word4 (SRK Hash)\nShadow Register for OTP Bank3 Word5 (SRK Hash)\nShadow Register for OTP Bank3 Word5 (SRK Hash)\nShadow Register for OTP Bank3 Word6 (SRK Hash)\nShadow Register for OTP Bank3 Word6 (SRK Hash)\nShadow Register for OTP Bank3 Word7 (SRK Hash)\nShadow Register for OTP Bank3 Word7 (SRK Hash)\nValue of OTP Bank5 Word7 (SRK Revoke)\nValue of OTP Bank5 Word7 (SRK Revoke)\nValue of OTP Bank5 Word0 (SW GP1)\nValue of OTP Bank5 Word0 (SW GP1)\nValue of OTP Bank5 Word1 (SW GP2)\nValue of OTP Bank5 Word1 (SW GP2)\nValue of OTP Bank5 Word2 (SW GP2)\nValue of OTP Bank5 Word2 (SW GP2)\nValue of OTP Bank5 Word3 (SW GP2)\nValue of OTP Bank5 Word3 (SW GP2)\nValue of OTP Bank5 Word4 (SW GP2)\nValue of OTP Bank5 Word4 (SW GP2)\nSticky bit Register\nSticky bit Register\nOTP Controller Timing Register\nOTP Controller Timing Register\nOTP Controller Timing Register\nOTP Controller Timing Register\nOTP Controller Version Register\nOTP Controller Version Register\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nCRC_ADDR\nDATA_END_ADDR\nDATA_START_ADDR\nOTPMK_CRC\nRSVD0\nDATA\nADDR\nBUSY\nCRC_FAIL\nCRC_TEST\nERROR\nRELOAD_SHADOWS\nRSVD0\nRSVD1\nWR_UNLOCK\nKey needed to unlock HW_OCOTP_DATA register.\nADDR\nBUSY\nCRC_FAIL\nCRC_TEST\nERROR\nRELOAD_SHADOWS\nRSVD0\nRSVD1\nWR_UNLOCK\nADDR\nBUSY\nCRC_FAIL\nCRC_TEST\nERROR\nRELOAD_SHADOWS\nRSVD0\nRSVD1\nWR_UNLOCK\nADDR\nBUSY\nCRC_FAIL\nCRC_TEST\nERROR\nRELOAD_SHADOWS\nRSVD0\nRSVD1\nWR_UNLOCK\nDATA\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nANALOG\nBOOT_CFG\nFIELD_RETURN\nGP1\nGP2\nGP3\nGP4\nGP4_RLOCK\nMAC_ADDR\nMEM_TRIM\nMISC_CONF\nOTPMK\nOTPMK_CRC\nROM_PATCH\nSJC_RESP\nSW_GP1\nSW_GP2_LOCK\nSW_GP2_RLOCK\nTESTER\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nREAD_FUSE\nRSVD0\nDATA\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nHAB_JDE\nLOCK\nSPARE\nHAB_JDE\nLOCK\nSPARE\nHAB_JDE\nLOCK\nSPARE\nHAB_JDE\nLOCK\nSPARE\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBITS\nBLOCK_DTCP_KEY\nBLOCK_ROM_PART\nFIELD_RETURN_LOCK\nJTAG_BLOCK_RELEASE\nRSVD0\nSRK_REVOKE_LOCK\nRELAX\nRSRVD0\nSTROBE_PROG\nSTROBE_READ\nWAIT\nRELAX_PROG\nRELAX_READ\nRSRVD0\nRSRVD0\nMAJOR\nMINOR\nSTEP\nPGC CPU Control Register\nPGC CPU Control Register\nPGC CPU Pull Down Sequence Control Register\nPGC CPU Pull Down Sequence Control Register\nPGC CPU Power Up Sequence Control Register\nPGC CPU Power Up Sequence Control Register\nPGC CPU Power Gating Controller Status Register\nPGC CPU Power Gating Controller Status Register\nPGC Mega Control Register\nPGC Mega Control Register\nPGC Mega Pull Down Sequence Control Register\nPGC Mega Pull Down Sequence Control Register\nPGC Mega Power Up Sequence Control Register\nPGC Mega Power Up Sequence Control Register\nPGC Mega Power Gating Controller Status Register\nPGC Mega Power Gating Controller Status Register\nPGC\nPGC\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nPower Control PCR must not change from power-down request …\nDo not switch off power even if pdn_req is asserted.\nSwitch off power when pdn_req is asserted.\nAfter a power-down request (pdn_req assertion), the PGC …\nAfter asserting isolation, the PGC waits a number of 32k …\nThere are two different silicon revisions: 1\nThere are two different silicon revisions: 1\nPower status\nThe target subsystem was not powered down for the previous …\nThe target subsystem was powered down for the previous …\nPower Control PCR must not change from power-down request …\nDo not switch off power even if pdn_req is asserted.\nSwitch off power when pdn_req is asserted.\nAfter a power-down request (pdn_req assertion), the PGC …\nAfter asserting isolation, the PGC waits a number of IPG …\nAfter a power-up request (pup_req assertion), the PGC …\nAfter asserting power toggle on/off signal (switch_b), the …\nPower status\nThe target subsystem was not powered down for the previous …\nThe target subsystem was powered down for the previous …\nPIT Upper Lifetime Timer Register\nPIT Upper Lifetime Timer Register\nPIT Lower Lifetime Timer Register\nPIT Lower Lifetime Timer Register\nPIT Module Control Register\nPIT Module Control Register\nPIT\nPIT\nno description available\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nLife Timer value\nLife Timer value\nFreeze\nModule Disable for PIT\nTimers continue to run in Debug mode.\nTimers are stopped in Debug mode.\nClock for standard PIT timers is enabled.\nClock for standard PIT timers is disabled.\nCurrent Timer Value Register\nCurrent Timer Value Register\nTimer Load Value Register\nTimer Load Value Register\nno description available\nTimer Control Register\nTimer Control Register\nTimer Flag Register\nTimer Flag Register\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCurrent Timer Value\nTimer Start Value\nChain Mode\nTimer Enable\nTimer Interrupt Enable\nTimer is not chained.\nTimer is chained to a previous timer. For example, for …\nTimer n is disabled.\nTimer n is enabled.\nInterrupt requests from Timer n are disabled.\nInterrupt is requested whenever TIF is set.\nTimer Interrupt Flag\nTimeout has not yet occurred.\nTimeout has occurred.\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 0\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Register 1\nMiscellaneous Control Register\nMiscellaneous Control Register\nMiscellaneous Control Register\nMiscellaneous Control Register\nMiscellaneous Control Register\nMiscellaneous Control Register\nMiscellaneous Control Register\nMiscellaneous Control Register\nPMU\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 1P1 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 2P5 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nRegulator 3P0 Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nDigital Regulator Core Register\nPMU\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nThis bit allows disabling the clock gate (always ungated) …\nThis field specifies the delay between powering up the …\nThis bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.\nThis field determines the bias current in the 24MHz …\nStatus bit that signals that the output of the 24-MHz …\nThis bit enables the detector that signals when the 24MHz …\nControl bit to power-down the analog bandgap reference …\nControl bit to disable the self-bias circuit in the analog …\nno description available\nStatus bit that signals the analog bandgap voltage is up …\nThis field indicates which chip source is being used for …\nConfigure the analog behavior in stop mode.\nPredivider for the source clock of the PLL’s.\nThis field powers down the 24M crystal oscillator if set …\nAllow the logic to automatically gate the clock when the …\nPrevent the logic from ever gating off the clock.\n0.5ms\n1.0ms\n2.0ms\n3.0ms\n4.0ms\n5.0ms\n6.0ms\n7.0ms\nTurn on the switch\nTurn off the switch\nDecrease current by 12.5%\nDecrease current by 25.0%\nDecrease current by 37.5%\nNominal\nUses coarse bias currents for startup\nUses bandgap-based bias currents for best performance.\nNominal VBG\nVBG+0.78%\nVBG+1.56%\nVBG+2.34%\nVBG-0.78%\nVBG-1.56%\nVBG-2.34%\nVBG-3.12%\nInternal ring oscillator\nRTC_XTAL\nAnalog regulators are ON.\nSUSPEND (DSM)\nSTOP (lower power)\nSTOP (very lower power)\nDivide by 1\nDivide by 2\nThis bit allows disabling the clock gate (always ungated) …\nThis field specifies the delay between powering up the …\nThis bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.\nThis field determines the bias current in the 24MHz …\nStatus bit that signals that the output of the 24-MHz …\nThis bit enables the detector that signals when the 24MHz …\nControl bit to power-down the analog bandgap reference …\nControl bit to disable the self-bias circuit in the analog …\nno description available\nStatus bit that signals the analog bandgap voltage is up …\nThis field indicates which chip source is being used for …\nConfigure the analog behavior in stop mode.\nPredivider for the source clock of the PLL’s.\nThis field powers down the 24M crystal oscillator if set …\nAllow the logic to automatically gate the clock when the …\nPrevent the logic from ever gating off the clock.\n0.5ms\n1.0ms\n2.0ms\n3.0ms\n4.0ms\n5.0ms\n6.0ms\n7.0ms\nTurn on the switch\nTurn off the switch\nDecrease current by 12.5%\nDecrease current by 25.0%\nDecrease current by 37.5%\nNominal\nUses coarse bias currents for startup\nUses bandgap-based bias currents for best performance.\nNominal VBG\nVBG+0.78%\nVBG+1.56%\nVBG+2.34%\nVBG-0.78%\nVBG-1.56%\nVBG-2.34%\nVBG-3.12%\nInternal ring oscillator\nRTC_XTAL\nAnalog regulators are ON.\nSUSPEND (DSM)\nSTOP (lower power)\nSTOP (very lower power)\nDivide by 1\nDivide by 2\nThis bit allows disabling the clock gate (always ungated) …\nThis field specifies the delay between powering up the …\nThis bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.\nThis field determines the bias current in the 24MHz …\nStatus bit that signals that the output of the 24-MHz …\nThis bit enables the detector that signals when the 24MHz …\nControl bit to power-down the analog bandgap reference …\nControl bit to disable the self-bias circuit in the analog …\nno description available\nStatus bit that signals the analog bandgap voltage is up …\nThis field indicates which chip source is being used for …\nConfigure the analog behavior in stop mode.\nPredivider for the source clock of the PLL’s.\nThis field powers down the 24M crystal oscillator if set …\nAllow the logic to automatically gate the clock when the …\nPrevent the logic from ever gating off the clock.\n0.5ms\n1.0ms\n2.0ms\n3.0ms\n4.0ms\n5.0ms\n6.0ms\n7.0ms\nTurn on the switch\nTurn off the switch\nDecrease current by 12.5%\nDecrease current by 25.0%\nDecrease current by 37.5%\nNominal\nUses coarse bias currents for startup\nUses bandgap-based bias currents for best performance.\nNominal VBG\nVBG+0.78%\nVBG+1.56%\nVBG+2.34%\nVBG-0.78%\nVBG-1.56%\nVBG-2.34%\nVBG-3.12%\nInternal ring oscillator\nRTC_XTAL\nAnalog regulators are ON.\nSUSPEND (DSM)\nSTOP (lower power)\nSTOP (very lower power)\nDivide by 1\nDivide by 2\nThis bit allows disabling the clock gate (always ungated) …\nThis field specifies the delay between powering up the …\nThis bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.\nThis field determines the bias current in the 24MHz …\nStatus bit that signals that the output of the 24-MHz …\nThis bit enables the detector that signals when the 24MHz …\nControl bit to power-down the analog bandgap reference …\nControl bit to disable the self-bias circuit in the analog …\nno description available\nStatus bit that signals the analog bandgap voltage is up …\nThis field indicates which chip source is being used for …\nConfigure the analog behavior in stop mode.\nPredivider for the source clock of the PLL’s.\nThis field powers down the 24M crystal oscillator if set …\nAllow the logic to automatically gate the clock when the …\nPrevent the logic from ever gating off the clock.\n0.5ms\n1.0ms\n2.0ms\n3.0ms\n4.0ms\n5.0ms\n6.0ms\n7.0ms\nTurn on the switch\nTurn off the switch\nDecrease current by 12.5%\nDecrease current by 25.0%\nDecrease current by 37.5%\nNominal\nUses coarse bias currents for startup\nUses bandgap-based bias currents for best performance.\nNominal VBG\nVBG+0.78%\nVBG+1.56%\nVBG+2.34%\nVBG-0.78%\nVBG-1.56%\nVBG-2.34%\nVBG-3.12%\nInternal ring oscillator\nRTC_XTAL\nAnalog regulators are ON.\nSUSPEND (DSM)\nSTOP (lower power)\nSTOP (very lower power)\nDivide by 1\nDivide by 2\nThis status bit is set to one when when any of the analog …\nThis status bit is set to one when when any of the digital …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis field selects the clk to be routed to anaclk1/1b.Not …\nThis field selects the clk to be routed to anaclk2/2b.Not …\nThis enables the LVDS input buffer for anaclk1/1b\nThis enables the LVDS output buffer for anaclk1/1b\nThis enables the LVDS input buffer for anaclk2/2b\nThis enables the LVDS output buffer for anaclk2/2b\nThis enables a feature that will clkgate (reset) all …\nThis enables a feature that will clkgate (reset) all …\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nLVDS1 (loopback)\nLVDS2 (not useful)\nMLB PLL\nPCIe ref clock (125M)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSATA ref clock (100M)\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nThis status bit is set to one when when any of the analog …\nThis status bit is set to one when when any of the digital …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis field selects the clk to be routed to anaclk1/1b.Not …\nThis field selects the clk to be routed to anaclk2/2b.Not …\nThis enables the LVDS input buffer for anaclk1/1b\nThis enables the LVDS output buffer for anaclk1/1b\nThis enables the LVDS input buffer for anaclk2/2b\nThis enables the LVDS output buffer for anaclk2/2b\nThis enables a feature that will clkgate (reset) all …\nThis enables a feature that will clkgate (reset) all …\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nLVDS1 (loopback)\nLVDS2 (not useful)\nMLB PLL\nPCIe ref clock (125M)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSATA ref clock (100M)\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nThis status bit is set to one when when any of the analog …\nThis status bit is set to one when when any of the digital …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis field selects the clk to be routed to anaclk1/1b.Not …\nThis field selects the clk to be routed to anaclk2/2b.Not …\nThis enables the LVDS input buffer for anaclk1/1b\nThis enables the LVDS output buffer for anaclk1/1b\nThis enables the LVDS input buffer for anaclk2/2b\nThis enables the LVDS output buffer for anaclk2/2b\nThis enables a feature that will clkgate (reset) all …\nThis enables a feature that will clkgate (reset) all …\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nLVDS1 (loopback)\nLVDS2 (not useful)\nMLB PLL\nPCIe ref clock (125M)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSATA ref clock (100M)\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nThis status bit is set to one when when any of the analog …\nThis status bit is set to one when when any of the digital …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis status bit is set to one when the temperature sensor …\nThis field selects the clk to be routed to anaclk1/1b.Not …\nThis field selects the clk to be routed to anaclk2/2b.Not …\nThis enables the LVDS input buffer for anaclk1/1b\nThis enables the LVDS output buffer for anaclk1/1b\nThis enables the LVDS input buffer for anaclk2/2b\nThis enables the LVDS output buffer for anaclk2/2b\nThis enables a feature that will clkgate (reset) all …\nThis enables a feature that will clkgate (reset) all …\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nArm PLL\nAudio PLL\nethernet ref clock (ENET_PLL)\nLVDS1 (loopback)\nLVDS2 (not useful)\nMLB PLL\nPCIe ref clock (125M)\nref_pfd0_clk == pll3_pfd0_clk\nref_pfd1_clk == pll3_pfd1_clk\nref_pfd2_clk == pll3_pfd2_clk\nref_pfd3_clk == pll3_pfd3_clk\nref_pfd4_clk == pll2_pfd0_clk\nref_pfd5_clk == pll2_pfd1_clk\nref_pfd6_clk == pll2_pfd2_clk\nref_pfd7_clk == pll2_pfd3_clk\nSATA ref clock (100M)\nSystem PLL\nUSB1 PLL clock\nUSB2 PLL clock\nVideo PLL\nxtal (24M)\nLSB of Post-divider for Audio PLL\nMSB of Post-divider for Audio PLL\nDefault value of “0”\nThis field defines the brown out voltage offset for the …\nReg0 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg1 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg2 brownout status bit.\nEnables the brownout detection.\nSignals that the voltage is above the brownout level for …\nNumber of clock periods (24MHz clock).\nPost-divider for video\ndivide by 1 (Default)\ndivide by 2\ndivide by 1 (Default)\ndivide by 2\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\n128\n256\n512\n64\ndivide by 1 (Default)\ndivide by 2\ndivide by 1\ndivide by 4\nLSB of Post-divider for Audio PLL\nMSB of Post-divider for Audio PLL\nDefault value of “0”\nThis field defines the brown out voltage offset for the …\nReg0 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg1 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg2 brownout status bit.\nEnables the brownout detection.\nSignals that the voltage is above the brownout level for …\nNumber of clock periods (24MHz clock).\nPost-divider for video\ndivide by 1 (Default)\ndivide by 2\ndivide by 1 (Default)\ndivide by 2\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\n128\n256\n512\n64\ndivide by 1 (Default)\ndivide by 2\ndivide by 1\ndivide by 4\nLSB of Post-divider for Audio PLL\nMSB of Post-divider for Audio PLL\nDefault value of “0”\nThis field defines the brown out voltage offset for the …\nReg0 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg1 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg2 brownout status bit.\nEnables the brownout detection.\nSignals that the voltage is above the brownout level for …\nNumber of clock periods (24MHz clock).\nPost-divider for video\ndivide by 1 (Default)\ndivide by 2\ndivide by 1 (Default)\ndivide by 2\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\n128\n256\n512\n64\ndivide by 1 (Default)\ndivide by 2\ndivide by 1\ndivide by 4\nLSB of Post-divider for Audio PLL\nMSB of Post-divider for Audio PLL\nDefault value of “0”\nThis field defines the brown out voltage offset for the …\nReg0 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg1 brownout status bit.\nEnables the brownout detection.\nNumber of clock periods (24MHz clock).\nThis field defines the brown out voltage offset for the …\nReg2 brownout status bit.\nEnables the brownout detection.\nSignals that the voltage is above the brownout level for …\nNumber of clock periods (24MHz clock).\nPost-divider for video\ndivide by 1 (Default)\ndivide by 2\ndivide by 1 (Default)\ndivide by 2\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\nBrownout, supply is below target minus brownout offset.\n128\n256\n512\n64\nBrownout offset = 0.100V\nBrownout offset = 0.175V\n128\n256\n512\n64\ndivide by 1 (Default)\ndivide by 2\ndivide by 1\ndivide by 4\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 1p1 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelects the source for the reference voltage of the weak …\n1.1V\n0.8V\nWeak-linreg output tracks low-power-bandgap voltage\nWeak-linreg output tracks VDD_SOC_IN voltage\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 1p1 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelects the source for the reference voltage of the weak …\n1.1V\n0.8V\nWeak-linreg output tracks low-power-bandgap voltage\nWeak-linreg output tracks VDD_SOC_IN voltage\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 1p1 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelects the source for the reference voltage of the weak …\n1.1V\n0.8V\nWeak-linreg output tracks low-power-bandgap voltage\nWeak-linreg output tracks VDD_SOC_IN voltage\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 1p1 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelects the source for the reference voltage of the weak …\n1.1V\n0.8V\nWeak-linreg output tracks low-power-bandgap voltage\nWeak-linreg output tracks VDD_SOC_IN voltage\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 2p5 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\n2.10V\n2.50V\n2.875V\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 2p5 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\n2.10V\n2.50V\n2.875V\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 2p5 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\n2.10V\n2.50V\n2.875V\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output.\nControl bit to enable the pull-down circuitry in the …\nEnables the weak 2p5 regulator\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\n2.10V\n2.50V\n2.875V\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output to be set by …\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelect input voltage source for LDO_3P0 from either …\n2.625V\n3.000V\n3.400V\nUtilize VBUS OTG1 power\nUtilize VBUS OTG2 power\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output to be set by …\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelect input voltage source for LDO_3P0 from either …\n2.625V\n3.000V\n3.400V\nUtilize VBUS OTG1 power\nUtilize VBUS OTG2 power\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output to be set by …\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelect input voltage source for LDO_3P0 from either …\n2.625V\n3.000V\n3.400V\nUtilize VBUS OTG1 power\nUtilize VBUS OTG2 power\nControl bits to adjust the regulator brownout offset …\nStatus bit that signals when a brownout is detected on the …\nControl bit to enable the brownout circuitry in the …\nControl bit to enable the current-limit circuitry in the …\nControl bit to enable the regulator output to be set by …\nStatus bit that signals when the regulator output is ok. 1 …\nControl bits to adjust the regulator output voltage\nSelect input voltage source for LDO_3P0 from either …\n2.625V\n3.000V\n3.400V\nUtilize VBUS OTG1 power\nUtilize VBUS OTG2 power\nIf set, increases the gate drive on power gating FETs to …\nRegulator voltage ramp rate.\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the ARM core …\nThis bit field defines the adjustment bits to calibrate …\nThis bit field defines the target voltage for the vpu/gpu …\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the SOC power …\nFast\nMedium Fast\nMedium Slow\nSlow\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nIf set, increases the gate drive on power gating FETs to …\nRegulator voltage ramp rate.\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the ARM core …\nThis bit field defines the adjustment bits to calibrate …\nThis bit field defines the target voltage for the vpu/gpu …\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the SOC power …\nFast\nMedium Fast\nMedium Slow\nSlow\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nIf set, increases the gate drive on power gating FETs to …\nRegulator voltage ramp rate.\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the ARM core …\nThis bit field defines the adjustment bits to calibrate …\nThis bit field defines the target voltage for the vpu/gpu …\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the SOC power …\nFast\nMedium Fast\nMedium Slow\nSlow\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nIf set, increases the gate drive on power gating FETs to …\nRegulator voltage ramp rate.\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the ARM core …\nThis bit field defines the adjustment bits to calibrate …\nThis bit field defines the target voltage for the vpu/gpu …\nThis bit field defines the adjustment bits to calibrate …\nThis field defines the target voltage for the SOC power …\nFast\nMedium Fast\nMedium Slow\nSlow\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nNo adjustment\n0.25%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n2.00%\n0.50%\n0.75%\n1.00%\n1.25%\n1.50%\n1.75%\n0.25%\n0.50%\nPower gated off\nTarget core voltage = 0.725V\nTarget core voltage = 1.100V\nTarget core voltage = 0.750V\nTarget core voltage = 0.775V\nTarget core voltage = 1.450V\nPower FET switched full on. No regulation.\nPWM Source Select Register\nPWM Source Select Register\nFault Control Register\nFault Control Register\nFault Control 2 Register\nFault Control 2 Register\nFault Filter Register\nFault Filter Register\nFault Status Register\nFault Status Register\nFault Test Register\nFault Test Register\nMask Register\nMask Register\nMaster Control Register\nMaster Control Register\nMaster Control 2 Register\nMaster Control 2 Register\nOutput Enable Register\nOutput Enable Register\nPWM\nPWM\nPWM\nPWM\nPWM\nCluster SM%s, containing SM?CNT, SM?INIT, SM?CTRL2, …\nSoftware Controlled Output Register\nSoftware Controlled Output Register\nReturns the argument unchanged.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nAcquire a vaild, but possibly aliased, instance.\nCalls <code>U::from(self)</code>.\nReturns the instance number <code>N</code> for a peripheral instance.\nSubmodule 0 PWM23 Control Select\nSubmodule 0 PWM45 Control Select\nSubmodule 1 PWM23 Control Select\nSubmodule 1 PWM45 Control Select\nSubmodule 2 PWM23 Control Select\nSubmodule 2 PWM45 Control Select\nSubmodule 3 PWM23 Control Select\nSubmodule 3 PWM45 Control Select\nGenerated SM0PWM23 signal is used by the deadtime logic.\nInverted generated SM0PWM23 signal is used by the deadtime …\nSWCOUT[SM0OUT23] is used by the deadtime logic.\nPWM0_EXTA signal is used by the deadtime logic.\nGenerated SM0PWM45 signal is used by the deadtime logic.\nInverted generated SM0PWM45 signal is used by the deadtime …\nSWCOUT[SM0OUT45] is used by the deadtime logic.\nPWM0_EXTB signal is used by the deadtime logic.\nGenerated SM1PWM23 signal is used by the deadtime logic.\nInverted generated SM1PWM23 signal is used by the deadtime …\nSWCOUT[SM1OUT23] is used by the deadtime logic.\nPWM1_EXTA signal is used by the deadtime logic.\nGenerated SM1PWM45 signal is used by the deadtime logic.\nInverted generated SM1PWM45 signal is used by the deadtime …\nSWCOUT[SM1OUT45] is used by the deadtime logic.\nPWM1_EXTB signal is used by the deadtime logic.\nGenerated SM2PWM23 signal is used by the deadtime logic.\nInverted generated SM2PWM23 signal is used by the deadtime …\nSWCOUT[SM2OUT23] is used by the deadtime logic.\nPWM2_EXTA signal is used by the deadtime logic.\nGenerated SM2PWM45 signal is used by the deadtime logic.\nInverted generated SM2PWM45 signal is used by the deadtime …\nSWCOUT[SM2OUT45] is used by the deadtime logic.\nPWM2_EXTB signal is used by the deadtime logic.\nGenerated SM3PWM23 signal is used by the deadtime logic.\nInverted generated SM3PWM23 signal is used by the deadtime …\nSWCOUT[SM3OUT23] is used by the deadtime logic.\nPWM3_EXTA signal is used by the deadtime logic.\nGenerated SM3PWM45 signal is used by the deadtime logic.\nInverted generated SM3PWM45 signal is used by the deadtime …\nSWCOUT[SM3OUT45] is used by the deadtime logic.\nPWM3_EXTB signal is used by the deadtime logic.\nAutomatic Fault Clearing\nFault Interrupt Enables\nFault Level\nFault Safety Mode\nManual fault clearing. PWM outputs disabled by this fault …\nAutomatic fault clearing. PWM outputs disabled by this …\nFAULTx CPU interrupt requests disabled.\nFAULTx CPU interrupt requests enabled.\nA logic 0 on the fault input indicates a fault condition.\nA logic 1 on the fault input indicates a fault condition.\nNormal mode. PWM outputs disabled by this fault are not …\nSafe mode. PWM outputs disabled by this fault are not …\nNo Combinational Path From Fault Input To PWM Output\nThere is a combinational link from the fault inputs to the …\nThe direct combinational path from the fault inputs to the …\nFault Filter Count\nFault Filter Period\nFault Glitch Stretch Enable\nFault input glitch stretching is disabled.\nInput fault signals will be stretched to at least 2 IPBus …\nFault Flags\nFiltered Fault Pins\nFull Cycle\nHalf Cycle Fault Recovery\nNo fault on the FAULTx pin.\nFault on the FAULTx pin.\nPWM outputs are not re-enabled at the start of a full cycle\nPWM outputs are re-enabled at the start of a full cycle\nPWM outputs are not re-enabled at the start of a half …\nPWM outputs are re-enabled at the start of a half cycle …\nFault Test\nNo fault\nCause a simulated fault\nPWM_A Masks\nPWM_B Masks\nPWM_X Masks\nUpdate Mask Bits Immediately\nPWM_A output normal.\nPWM_A output masked.\nPWM_B output normal.\nPWM_B output masked.\nPWM_X output normal.\nPWM_X output masked.\nNormal operation. MASK* bits within the corresponding …\nImmediate operation. MASK* bits within the corresponding …\nClear Load Okay\nCurrent Polarity\nLoad Okay\nRun\nMonitor PLL State\nNot locked. Do not monitor PLL operation. Resetting of the …\nNot locked. Monitor PLL operation to automatically disable …\nLocked. Do not monitor PLL operation. Resetting of the …\nLocked. Monitor PLL operation to automatically disable the …\nPWM23 is used to generate complementary PWM pair in the …\nPWM45 is used to generate complementary PWM pair in the …\nDo not load new values.\nLoad prescaler, modulus, and PWM values of the …\nPWM generator is disabled in the corresponding submodule.\nPWM generator is enabled in the corresponding submodule.\nPWM_A Output Enables\nPWM_B Output Enables\nPWM_X Output Enables\nPWM_A output disabled.\nPWM_A output enabled.\nPWM_B output disabled.\nPWM_B output enabled.\nPWM_X output disabled.\nPWM_X output enabled.\nSubmodule 0 Software Controlled Output 23\nSubmodule 0 Software Controlled Output 45\nSubmodule 1 Software Controlled Output 23\nSubmodule 1 Software Controlled Output 45\nSubmodule 2 Software Controlled Output 23\nSubmodule 2 Software Controlled Output 45\nSubmodule 3 Software Controlled Output 23\nSubmodule 3 Software Controlled Output 45\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nA logic 0 is supplied to the deadtime generator of …\nA logic 1 is supplied to the deadtime generator of …\nCluster SM%s, containing SM?CNT, SM?INIT, SM?CTRL2, …\nCapture Compare A Register\nCapture Compare A Register\nCapture Compare B Register\nCapture Compare B Register\nCapture Compare X Register\nCapture Compare X Register\nCapture Control A Register\nCapture Control A Register\nCapture Control B Register\nCapture Control B Register\nCapture Control X Register\nCapture Control X Register\nCounter Register\nCounter Register\nControl Register\nControl Register\nControl 2 Register\nControl 2 Register\nCapture Value 0 Register\nCapture Value 0 Register\nCapture Value 0 Cycle Register\nCapture Value 0 Cycle Register\nCapture Value 1 Register\nCapture Value 1 Register\nCapture Value 1 Cycle Register\nCapture Value 1 Cycle Register\nCapture Value 2 Register\nCapture Value 2 Register\nCapture Value 2 Cycle Register\nCapture Value 2 Cycle Register\nCapture Value 3 Register\nCapture Value 3 Register\nCapture Value 3 Cycle Register\nCapture Value 3 Cycle Register\nCapture Value 4 Register\nCapture Value 4 Register\nCapture Value 4 Cycle Register\nCapture Value 4 Cycle Register\nCapture Value 5 Register\nCapture Value 5 Register\nCapture Value 5 Cycle Register\nCapture Value 5 Cycle Register\nFault Disable Mapping Register 0\nFault Disable Mapping Register 0\nFault Disable Mapping Register 1\nFault Disable Mapping Register 1\nDMA Enable Register\nDMA Enable Register\nDeadtime Count Register 0\nDeadtime Count Register 0\nDeadtime Count Register 1\nDeadtime Count Register 1\nFractional Value Register 1\nFractional Value Register 1\nFractional Value Register 2\nFractional Value Register 2\nFractional Value Register 3\nFractional Value Register 3\nFractional Value Register 4\nFractional Value Register 4\nFractional Value Register 5\nFractional Value Register 5\nFractional Control Register\nFractional Control Register\nInitial Count Register\nInitial Count Register\nInterrupt Enable Register\nInterrupt Enable Register\nOutput Control Register\nOutput Control Register\nStatus Register\nStatus Register\nOutput Trigger Control Register\nOutput Trigger Control Register\nValue Register 0\nValue Register 0\nValue Register 1\nValue Register 1\nValue Register 2\nValue Register 2\nValue Register 3\nValue Register 3\nValue Register 4\nValue Register 4\nValue Register 5\nValue Register 5\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEdge Compare A\nEdge Counter A\nEdge Compare B\nEdge Counter B\nEdge Compare X\nEdge Counter X\nArm A\nCapture A0 FIFO Word Count\nCapture A1 FIFO Word Count\nCapture A FIFOs Water Mark\nEdge A 0\nEdge A 1\nEdge Counter A Enable\nInput Select A\nOne Shot Mode A\nInput capture operation is disabled.\nInput capture operation as specified by CAPTCTRLA[EDGAx] …\nDisabled\nCapture falling edges\nCapture rising edges\nCapture any edge\nDisabled\nCapture falling edges\nCapture rising edges\nCapture any edge\nEdge counter disabled and held in reset\nEdge counter enabled\nRaw PWM_A input signal selected as source.\nOutput of edge counter/compare selected as source. Note …\nFree running mode is selected. If both capture circuits …\nOne shot mode is selected. If both capture circuits are …\nArm B\nCapture B0 FIFO Word Count\nCapture B1 FIFO Word Count\nCapture B FIFOs Water Mark\nEdge B 0\nEdge B 1\nEdge Counter B Enable\nInput Select B\nOne Shot Mode B\nInput capture operation is disabled.\nInput capture operation as specified by CAPTCTRLB[EDGBx] …\nDisabled\nCapture falling edges\nCapture rising edges\nCapture any edge\nDisabled\nCapture falling edges\nCapture rising edges\nCapture any edge\nEdge counter disabled and held in reset\nEdge counter enabled\nRaw PWM_B input signal selected as source.\nOutput of edge counter/compare selected as source. Note …\nFree running mode is selected. If both capture circuits …\nOne shot mode is selected. If both capture circuits are …\nArm X\nCapture X FIFOs Water Mark\nCapture X0 FIFO Word Count\nCapture X1 FIFO Word Count\nEdge Counter X Enable\nEdge X 0\nEdge X 1\nInput Select X\nOne Shot Mode Aux\nInput capture operation is disabled.\nInput capture operation as specified by CAPTCTRLX[EDGXx] …\nEdge counter disabled and held in reset\nEdge counter enabled\nDisabled\nCapture falling edges\nCapture rising edges\nCapture any edge\nDisabled\nCapture falling edges\nCapture rising edges\nCapture any edge\nRaw PWM_X input signal selected as source.\nOutput of edge counter/compare selected as source. Note …\nFree running mode is selected. If both capture circuits …\nOne shot mode is selected. If both capture circuits are …\nCounter Register Bits\nCompare Mode\nDouble Switching Enable\nPWMX Double Switching Enable\nDeadtime\nFull Cycle Reload\nHalf Cycle Reload\nLoad Frequency\nLoad Mode Select\nPrescaler\nSplit the DBLPWM signal to PWMA and PWMB\nClock Source Select\nDebug Enable\nForce Initialization\nThis read/write bit determines the source of the FORCE …\nFRCEN\nIndependent or Complementary Pair Operation\nInitialization Control Select\nPWM23 Initial Value\nPWM45 Initial Value\nPWM_X Initial Value\nReload Source Select\nWAIT Enable\nThe IPBus clock is used as the clock for the local …\nEXT_CLK is used as the clock for the local prescaler and …\nSubmodule 0’s clock (AUX_CLK) is used as the source …\nThe local force signal, CTRL2[FORCE], from this submodule …\nThe master force signal from submodule 0 is used to force …\nThe local reload signal from this submodule is used to …\nThe master reload signal from submodule0 is used to force …\nThe local sync signal from this submodule is used to force …\nThe master sync signal from submodule0 is used to force …\nThe external force signal, EXT_FORCE, from outside the PWM …\nThe external sync signal, EXT_SYNC, from outside the PWM …\nInitialization from a FORCE_OUT is disabled.\nInitialization from a FORCE_OUT is enabled.\nPWM_A and PWM_B form a complementary PWM pair.\nPWM_A and PWM_B outputs are independent PWMs.\nLocal sync (PWM_X) causes initialization.\nMaster reload from submodule 0 causes initialization. This …\nMaster sync from submodule 0 causes initialization. This …\nEXT_SYNC causes initialization.\nThe local RELOAD signal is used to reload registers.\nThe master RELOAD signal (from submodule 0) is used to …\nThe VAL* registers and the PWM counter are compared using …\nThe VAL* registers and the PWM counter are compared using …\nDouble switching disabled.\nDouble switching enabled.\nPWMX double pulse disabled.\nPWMX double pulse enabled.\nFull-cycle reloads disabled.\nFull-cycle reloads enabled.\nHalf-cycle reloads disabled.\nHalf-cycle reloads enabled.\nEvery PWM opportunity\nEvery 2 PWM opportunities\nEvery 11 PWM opportunities\nEvery 12 PWM opportunities\nEvery 13 PWM opportunities\nEvery 14 PWM opportunities\nEvery 15 PWM opportunities\nEvery 16 PWM opportunities\nEvery 3 PWM opportunities\nEvery 4 PWM opportunities\nEvery 5 PWM opportunities\nEvery 6 PWM opportunities\nEvery 7 PWM opportunities\nEvery 8 PWM opportunities\nEvery 9 PWM opportunities\nEvery 10 PWM opportunities\nBuffered registers of this submodule are loaded and take …\nBuffered registers of this submodule are loaded and take …\nPWM clock frequency = fclk\nPWM clock frequency = fclk/2\nPWM clock frequency = fclk/4\nPWM clock frequency = fclk/8\nPWM clock frequency = fclk/16\nPWM clock frequency = fclk/32\nPWM clock frequency = fclk/64\nPWM clock frequency = fclk/128\nDBLPWM is not split. PWMA and PWMB each have double pulses.\nDBLPWM is split to PWMA and PWMB.\nCAPTVAL0\nCVAL0CYC\nCAPTVAL1\nCVAL1CYC\nCAPTVAL2\nCVAL2CYC\nCAPTVAL3\nCVAL3CYC\nCAPTVAL4\nCVAL4CYC\nCAPTVAL5\nCVAL5CYC\nPWM_A Fault Disable Mask 0\nPWM_B Fault Disable Mask 0\nPWM_X Fault Disable Mask 0\nPWM_A Fault Disable Mask 1\nPWM_B Fault Disable Mask 1\nPWM_X Fault Disable Mask 1\nCapture A0 FIFO DMA Enable\nCapture A1 FIFO DMA Enable\nCapture DMA Enable Source Select\nCapture B0 FIFO DMA Enable\nCapture B1 FIFO DMA Enable\nCapture X0 FIFO DMA Enable\nCapture X1 FIFO DMA Enable\nFIFO Watermark AND Control\nValue Registers DMA Enable\nRead DMA requests disabled.\nExceeding a FIFO watermark sets the DMA read request. This …\nA local sync (VAL1 matches counter) sets the read DMA …\nA local reload (STS[RF] being set) sets the read DMA …\nSelected FIFO watermarks are OR’ed together.\nSelected FIFO watermarks are AND’ed together.\nDMA write requests disabled\nDMA write requests for the VALx and FRACVALx registers …\nDTCNT0\nDTCNT1\nFractional Value 1 Register\nFractional Value 2\nFractional Value 3\nFractional Value 4\nFractional Value 5\nFractional Cycle PWM Period Enable\nFractional Cycle Placement Enable for PWM_A\nFractional Cycle Placement Enable for PWM_B\nFractional Delay Circuit Power Up\nTest Status Bit\nDisable fractional cycle length for the PWM period.\nEnable fractional cycle length for the PWM period.\nDisable fractional cycle placement for PWM_A.\nEnable fractional cycle placement for PWM_A.\nDisable fractional cycle placement for PWM_B.\nEnable fractional cycle placement for PWM_B.\nTurn off fractional delay logic.\nPower up fractional delay logic.\nInitial Count Register Bits\nCapture A 0 Interrupt Enable\nCapture A 1 Interrupt Enable\nCapture B 0 Interrupt Enable\nCapture B 1 Interrupt Enable\nCompare Interrupt Enables\nCapture X 0 Interrupt Enable\nCapture X 1 Interrupt Enable\nReload Error Interrupt Enable\nReload Interrupt Enable\nInterrupt request disabled for STS[CFA0].\nInterrupt request enabled for STS[CFA0].\nInterrupt request disabled for STS[CFA1].\nInterrupt request enabled for STS[CFA1].\nInterrupt request disabled for STS[CFB0].\nInterrupt request enabled for STS[CFB0].\nInterrupt request disabled for STS[CFB1].\nInterrupt request enabled for STS[CFB1].\nThe corresponding STS[CMPF] bit will not cause an …\nThe corresponding STS[CMPF] bit will cause an interrupt …\nInterrupt request disabled for STS[CFX0].\nInterrupt request enabled for STS[CFX0].\nInterrupt request disabled for STS[CFX1].\nInterrupt request enabled for STS[CFX1].\nSTS[REF] CPU interrupt requests disabled\nSTS[REF] CPU interrupt requests enabled\nSTS[RF] CPU interrupt requests disabled\nSTS[RF] CPU interrupt requests enabled\nPWM_A Output Polarity\nPWM_B Output Polarity\nPWM_X Output Polarity\nPWM_A Fault State\nPWM_A Input\nPWM_B Fault State\nPWM_B Input\nPWM_X Fault State\nPWM_X Input\nPWM_A output not inverted. A high level on the PWM_A pin …\nPWM_A output inverted. A low level on the PWM_A pin …\nPWM_B output not inverted. A high level on the PWM_B pin …\nPWM_B output inverted. A low level on the PWM_B pin …\nPWM_X output not inverted. A high level on the PWM_X pin …\nPWM_X output inverted. A low level on the PWM_X pin …\nOutput is forced to logic 0 state prior to consideration …\nOutput is forced to logic 1 state prior to consideration …\nOutput is tristated.\nOutput is tristated.\nOutput is forced to logic 0 state prior to consideration …\nOutput is forced to logic 1 state prior to consideration …\nOutput is tristated.\nOutput is tristated.\nOutput is forced to logic 0 state prior to consideration …\nOutput is forced to logic 1 state prior to consideration …\nOutput is tristated.\nOutput is tristated.\nCapture Flag A0\nCapture Flag A1\nCapture Flag B0\nCapture Flag B1\nCapture Flag X0\nCapture Flag X1\nCompare Flags\nReload Error Flag\nReload Flag\nRegisters Updated Flag\nNo compare event has occurred for a particular VALx value.\nA compare event has occurred for a particular VALx value.\nNo reload error occurred.\nReload signal occurred with non-coherent data and MCTRL…\nNo new reload cycle since last STS[RF] clearing\nNew reload cycle since last STS[RF] clearing\nNo register update has occurred since last reload.\nAt least one of the double buffered registers has been …\nOutput Trigger Enables\nOutput Trigger 0 Source Select\nOutput Trigger 1 Source Select\nTrigger frequency\nPWM_OUT_TRIGx will not set when the counter value matches …\nPWM_OUT_TRIGx will set when the counter value matches the …\nRoute the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.\nRoute the PWMA output to the PWM_OUT_TRIG0 port.\nRoute the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.\nRoute the PWMB output to the PWM_OUT_TRIG1 port.\nTrigger outputs are generated during every PWM period even …\nTrigger outputs are generated only during the final PWM …\nValue Register 0\nValue Register 1\nValue Register 2\nValue Register 3\nValue Register 4\nValue Register 5\nAlpha Surface Buffer Pointer\nAlpha Surface Buffer Pointer\nOverlay Color Key High\nOverlay Color Key High\nOverlay Color Key Low\nOverlay Color Key Low\nAlpha Surface Control\nAlpha Surface Control\nAlpha Surface Pitch\nAlpha Surface Pitch\nColor Space Conversion Coefficient Register 0\nColor Space Conversion Coefficient Register 0\nColor Space Conversion Coefficient Register 1\nColor Space Conversion Coefficient Register 1\nColor Space Conversion Coefficient Register 2\nColor Space Conversion Coefficient Register 2\nControl Register 0\nControl Register 0\nControl Register 0\nControl Register 0\nControl Register 0\nControl Register 0\nControl Register 0\nControl Register 0\nNext Frame Pointer\nNext Frame Pointer\nAlpha Surface Lower Right Coordinate\nAlpha Surface Lower Right Coordinate\nAlpha Surface Upper Left Coordinate\nAlpha Surface Upper Left Coordinate\nOutput Frame Buffer Pointer\nOutput Frame Buffer Pointer\nOutput Frame Buffer Pointer #2\nOutput Frame Buffer Pointer #2\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Buffer Control Register\nOutput Surface Lower Right Coordinate\nOutput Surface Lower Right Coordinate\nOutput Buffer Pitch")